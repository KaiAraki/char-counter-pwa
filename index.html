<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>文字アドベンチャーラボ</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#f6f6f6">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --bg-gradient: linear-gradient(135deg, #b1c8ff 0%, #f7d4f5 48%, #fff5c2 100%);
      --surface: rgba(255, 255, 255, 0.78);
      --surface-strong: rgba(255, 255, 255, 0.92);
      --border: rgba(255, 255, 255, 0.45);
      --text-main: #2c2c30;
      --text-sub: #4f4f57;
      --accent: #5b63ff;
      --accent-dark: #3c3fca;
      --shadow: 0 25px 45px rgba(38, 45, 74, 0.15);
      --radius-lg: 26px;
      --radius-md: 18px;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: "Noto Sans JP", "Hiragino Sans", "ヒラギノ角ゴ ProN", "Yu Gothic", YuGothic, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      line-height: 1.7;
      min-height: 100vh;
      background: var(--bg-gradient);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: clamp(24px, 5vw, 48px);
      padding-bottom: clamp(120px, 22vh, 160px);
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }
    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: -30%;
      z-index: -1;
      pointer-events: none;
      background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.8), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(255, 184, 255, 0.7), transparent 60%),
        radial-gradient(circle at 40% 80%, rgba(165, 194, 255, 0.7), transparent 60%);
      filter: blur(60px);
      opacity: 0.65;
      animation: aurora-flow 36s linear infinite;
      transform-origin: center;
    }
    body::after {
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.75), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255, 240, 200, 0.6), transparent 60%),
        radial-gradient(circle at 60% 20%, rgba(180, 255, 236, 0.5), transparent 65%);
      filter: blur(80px);
      opacity: 0.55;
      animation-duration: 48s;
      animation-direction: reverse;
    }
    @keyframes aurora-flow {
      0% {
        transform: translate3d(-4%, -4%, 0) rotate(0deg) scale(1.05);
      }
      50% {
        transform: translate3d(4%, 3%, 0) rotate(180deg) scale(1.1);
      }
      100% {
        transform: translate3d(-4%, -4%, 0) rotate(360deg) scale(1.05);
      }
    }
    .wrap {
      width: min(960px, 100%);
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: clamp(24px, 4vw, 48px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }
    [data-view] {
      display: none;
    }
    [data-view].is-active {
      display: block;
    }
    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: clamp(20px, 4vw, 36px);
    }
    .headline {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: clamp(1.2rem, 4vw, 1.8rem);
      font-weight: 700;
      letter-spacing: 0.05em;
    }
    .headline-icon {
      width: clamp(38px, 6vw, 52px);
      height: clamp(38px, 6vw, 52px);
      display: grid;
      place-items: center;
      border-radius: 16px;
      background: var(--surface-strong);
      box-shadow: 0 12px 25px rgba(91, 99, 255, 0.15);
      color: var(--accent);
    }
    .headline small {
      display: block;
      font-size: clamp(0.65rem, 2.1vw, 0.78rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--accent);
    }
    header p {
      margin: 0;
      color: var(--text-sub);
      font-size: clamp(0.92rem, 2.6vw, 1.05rem);
    }
    .mascot {
      display: flex;
      align-items: center;
      gap: clamp(16px, 4vw, 28px);
      padding: clamp(16px, 3vw, 24px);
      margin-bottom: clamp(18px, 3.4vw, 30px);
      background: rgba(255, 255, 255, 0.88);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      position: relative;
      overflow: hidden;
    }
    .mascot::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at top right, rgba(91, 99, 255, 0.18), transparent 60%);
    }
    .mascot-figure {
      position: relative;
      display: grid;
      place-items: center;
      width: clamp(70px, 14vw, 90px);
      height: clamp(70px, 14vw, 90px);
      border-radius: 24px;
      background: linear-gradient(135deg, #fff 0%, #f0f3ff 100%);
      border: 1px solid rgba(91, 99, 255, 0.25);
      box-shadow: 0 18px 24px rgba(59, 63, 204, 0.18);
    }
    .mascot-face {
      width: 78%;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
    }
    .mascot-face img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
    }
    .mascot-hand {
      position: absolute;
      bottom: clamp(10px, 2vw, 16px);
      right: clamp(10px, 2vw, 16px);
      width: clamp(24px, 4vw, 28px);
      height: clamp(24px, 4vw, 28px);
      border-radius: 50% 50% 45% 45%;
      background: #ffd9ef;
      box-shadow: inset -3px -5px 0 rgba(255, 176, 216, 0.6);
      transform-origin: top right;
    }
    .mascot-message {
      flex: 1;
      margin: 0;
      color: var(--text-sub);
      font-size: clamp(0.95rem, 3vw, 1.05rem);
      line-height: 1.6;
    }
    .mascot.is-animate .mascot-face {
      animation: mascot-bounce 0.7s ease;
    }
    .mascot.is-animate .mascot-hand {
      animation: mascot-wave 0.7s ease;
    }
    @keyframes mascot-bounce {
      0% { transform: translateY(0) scale(1); }
      30% { transform: translateY(-6px) scale(1.05); }
      60% { transform: translateY(2px) scale(0.98); }
      100% { transform: translateY(0) scale(1); }
    }
    @keyframes mascot-wave {
      0% { transform: rotate(0deg); }
      35% { transform: rotate(-18deg); }
      70% { transform: rotate(12deg); }
      100% { transform: rotate(0deg); }
    }
    textarea {
      width: 100%;
      min-height: clamp(260px, 45vh, 480px);
      padding: clamp(16px, 3.8vw, 22px);
      font-size: clamp(1rem, 3.3vw, 1.08rem);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      background: var(--surface-strong);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45);
      resize: vertical;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }
    textarea:focus {
      outline: none;
      border-color: rgba(91, 99, 255, 0.6);
      box-shadow: 0 0 0 4px rgba(91, 99, 255, 0.18);
    }
    textarea::placeholder {
      color: rgba(79, 79, 87, 0.55);
    }
    .stats {
      display: grid;
      gap: clamp(14px, 2.4vw, 20px);
      margin: clamp(18px, 3vw, 28px) 0;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .box {
      padding: clamp(14px, 2.6vw, 20px);
      border-radius: var(--radius-md);
      background: var(--surface-strong);
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(38, 45, 74, 0.08);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .box::after {
      content: "";
      position: absolute;
      inset: -60% 60% 60% -60%;
      background: radial-gradient(circle at top left, rgba(91, 99, 255, 0.18), transparent 60%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .box:hover::after {
      opacity: 1;
    }
    @supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
      .wrap {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.78));
      }
      .box {
        background: linear-gradient(140deg, rgba(255, 255, 255, 0.98), rgba(246, 248, 255, 0.82));
      }
    }
    .box strong {
      display: block;
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      margin-top: 6px;
      letter-spacing: 0.03em;
    }
    .box span {
      display: block;
      color: var(--text-sub);
      font-size: 0.92rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: flex-end;
    }
    button {
      padding: 12px 22px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent) 0%, #7a7fff 100%);
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 18px 30px rgba(91, 99, 255, 0.25);
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 24px 36px rgba(60, 63, 202, 0.28);
      filter: brightness(1.05);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 14px 20px rgba(60, 63, 202, 0.22);
    }
    footer {
      margin-top: clamp(24px, 4vw, 40px);
      color: var(--text-sub);
      font-size: clamp(0.85rem, 2.8vw, 0.96rem);
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .badge {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(91, 99, 255, 0.12);
      color: var(--accent);
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .global-nav {
      position: fixed;
      left: 50%;
      bottom: clamp(14px, 4vw, 28px);
      transform: translateX(-50%);
      width: min(640px, calc(100% - clamp(24px, 10vw, 80px)));
      z-index: 20;
    }
    .global-nav-inner {
      display: flex;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(15, 14, 43, 0.18);
      box-shadow: 0 22px 38px rgba(24, 27, 58, 0.16);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.22);
    }
    .nav-button {
      flex: 1;
      border: none;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.55);
      color: var(--text-main);
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      padding: 8px 12px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease, color 0.18s ease;
    }
    .nav-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 26px rgba(56, 63, 146, 0.22);
    }
    .nav-button.is-active {
      background: linear-gradient(135deg, #5b63ff 0%, #ff8ade 100%);
      color: #fff;
      box-shadow: 0 18px 32px rgba(91, 99, 255, 0.35);
    }
    .nav-button span {
      font-size: 0.68rem;
      letter-spacing: 0.16em;
    }
    .nav-button strong {
      font-size: 0.9rem;
      letter-spacing: 0.06em;
    }
    .nav-icon {
      width: 24px;
      height: 24px;
      display: grid;
      place-items: center;
    }
    .game-layout {
      display: grid;
      gap: clamp(20px, 3.6vw, 32px);
      align-items: start;
    }
    .game-canvas-wrap {
      position: relative;
      border-radius: var(--radius-md);
      padding: clamp(18px, 3vw, 26px);
      background: rgba(17, 22, 58, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 25px 45px rgba(26, 22, 66, 0.28);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(10px, 2.6vw, 16px);
    }
    #game-board {
      width: 100%;
      height: auto;
      display: block;
      background: rgba(8, 9, 30, 0.92);
      border-radius: 12px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
      image-rendering: pixelated;
    }
    .game-info {
      display: grid;
      gap: clamp(16px, 3vw, 24px);
    }
    .game-scoreboard {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }
    .game-scoreboard .box {
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 18px 32px rgba(28, 30, 82, 0.18);
    }
    .game-banner {
      margin: 0;
      padding: 14px 18px;
      border-radius: var(--radius-md);
      background: rgba(91, 99, 255, 0.12);
      color: var(--accent-dark);
      font-weight: 600;
    }
    .game-instruction {
      margin: 0;
      color: var(--text-sub);
      font-size: 0.92rem;
    }
    .game-touch-controls {
      display: none;
      width: 100%;
      margin-top: 0;
      align-self: stretch;
    }
    .game-touch-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-areas:
        "rotate rotate drop"
        "left down right";
      gap: 8px;
      width: 100%;
    }
    .game-touch-button {
      border: none;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.92);
      color: var(--text-main);
      box-shadow: 0 16px 28px rgba(30, 32, 84, 0.18);
      padding: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      font-weight: 600;
      letter-spacing: 0.04em;
      line-height: 1.1;
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
    }
    .game-touch-button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 10px 18px rgba(30, 32, 84, 0.24);
    }
    .game-touch-button[data-area="rotate"] { grid-area: rotate; }
    .game-touch-button[data-area="drop"] { grid-area: drop; }
    .game-touch-button[data-area="left"] { grid-area: left; }
    .game-touch-button[data-area="down"] { grid-area: down; }
    .game-touch-button[data-area="right"] { grid-area: right; }
    .game-touch-icon {
      font-size: 1.2rem;
    }
    .game-touch-text {
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    @media (max-width: 900px) {
      .game-touch-controls {
        display: block;
      }
    }
    @media (max-width: 640px) {
      body {
        padding: clamp(18px, 8vw, 32px);
        padding-bottom: clamp(120px, 30vw, 220px);
        align-items: stretch;
        justify-content: flex-start;
      }
      .wrap {
        padding: clamp(18px, 6vw, 32px);
      }
      .actions {
        justify-content: stretch;
      }
      button {
        width: 100%;
        justify-content: center;
      }
      .global-nav-inner {
        gap: 8px;
        padding: 9px 10px;
      }
      .nav-button {
        padding: 7px 10px;
        font-size: 0.88rem;
      }
      .game-touch-grid {
        gap: 6px;
      }
      .game-touch-button {
        padding: 8px 6px;
      }
      .game-touch-icon {
        font-size: 1.05rem;
      }
      .game-touch-text {
        font-size: 0.64rem;
      }
    }
    @media (max-width: 480px) {
      .game-touch-grid {
        gap: 5px;
      }
      .game-touch-button {
        padding: 7px 5px;
        gap: 3px;
      }
      .game-touch-text {
        letter-spacing: 0.08em;
      }
    }
    @media (min-width: 860px) {
      .game-layout {
        grid-template-columns: minmax(0, 0.95fr) minmax(220px, 0.85fr);
      }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="view is-active" data-view="counter" aria-labelledby="counter-title">
      <header>
        <div class="headline">
          <span class="headline-icon" aria-hidden="true">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 3L4 7V17L12 21L20 17V7L12 3Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
              <path d="M9 9H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
              <path d="M9 12H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
              <path d="M9 15H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
          </span>
          <div id="counter-title">
            <small>Word Party</small>
            文字カウント・ショータイム
          </div>
        </div>
        <p>文章づくりを盛り上げるステージへようこそ！リアルタイムで文字数・行数・単語数を測りながら、あなたのストーリーをノリノリに仕上げましょう。</p>
      </header>

      <section class="mascot" aria-live="polite">
        <div class="mascot-figure">
          <div class="mascot-face">
            <img id="mascot-face" src="assets/reaction-waiting.svg" alt="わくわくして入力を待つ表情">
          </div>
          <div class="mascot-hand"></div>
        </div>
        <p class="mascot-message" id="mascot-message">ステージは整ったよ！どんな文章で盛り上げる？</p>
      </section>

      <textarea id="t" placeholder="ここに文章を投げ込んで、言葉のショーを始めよう！"></textarea>

      <div class="stats" aria-live="polite">
        <div class="box">
          <span>Character</span>
          <strong id="chars">0</strong>
        </div>
        <div class="box">
          <span>Lines</span>
          <strong id="lines">0</strong>
        </div>
        <div class="box">
          <span>Words</span>
          <strong id="words">0</strong>
        </div>
      </div>

      <div class="actions">
        <button id="clear" type="button">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M3 6H21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 6V4H15V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M10 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M14 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M5 6L6 19C6.05535 19.5978 6.31954 20.1599 6.75041 20.58C7.18128 21.0002 7.75022 21.25 8.343 21.29H15.657C16.20498 21.25 16.8187 21.0002 17.2496 20.58C17.6805 20.1599 17.9447 19.5978 18 19L19 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          クリア
        </button>
      </div>

      <footer>
        <span class="badge">PWA Ready</span>
        オフラインでも利用OK。ホーム画面に置けば、いつでもどこでも文字ライブを楽しめます。
      </footer>
    </section>

    <section class="view" data-view="game" aria-labelledby="game-title">
      <header>
        <div class="headline">
          <span class="headline-icon" aria-hidden="true">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect x="3" y="4" width="18" height="12" rx="2" stroke="currentColor" stroke-width="1.5"/>
              <path d="M8 18L10 16H14L16 18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              <circle cx="9" cy="10" r="1" fill="currentColor"/>
              <circle cx="15" cy="10" r="1" fill="currentColor"/>
            </svg>
          </span>
          <div id="game-title">
            <small>Arcade Time</small>
            ポップドロップ・パズル
          </div>
        </div>
        <p>キラキラ降るブロックをさばいてハイスコアを狙う、ライトなテトリス風ミニゲーム。文章制作のクールダウンに、ちょっとしたエンタメタイムをどうぞ！</p>
      </header>

      <div class="game-layout">
        <div class="game-canvas-wrap">
          <canvas id="game-board" width="240" height="432" aria-describedby="game-banner"></canvas>
          <div class="game-touch-controls" aria-label="タッチ操作ボタン">
            <div class="game-touch-grid">
              <button class="game-touch-button" type="button" data-control="rotate" data-area="rotate" aria-label="回転">
                <span class="game-touch-icon" aria-hidden="true">↻</span>
                <span class="game-touch-text">回転</span>
              </button>
              <button class="game-touch-button" type="button" data-control="drop" data-area="drop" aria-label="ハードドロップ">
                <span class="game-touch-icon" aria-hidden="true">⤓</span>
                <span class="game-touch-text">落下</span>
              </button>
              <button class="game-touch-button" type="button" data-control="left" data-area="left" aria-label="左に移動">
                <span class="game-touch-icon" aria-hidden="true">←</span>
                <span class="game-touch-text">左</span>
              </button>
              <button class="game-touch-button" type="button" data-control="down" data-area="down" aria-label="下に移動">
                <span class="game-touch-icon" aria-hidden="true">↓</span>
                <span class="game-touch-text">下</span>
              </button>
              <button class="game-touch-button" type="button" data-control="right" data-area="right" aria-label="右に移動">
                <span class="game-touch-icon" aria-hidden="true">→</span>
                <span class="game-touch-text">右</span>
              </button>
            </div>
          </div>
        </div>
        <div class="game-info">
          <p class="game-banner" id="game-banner">ゲームスタートを押して、ブロックショーを開演しよう！</p>
          <div class="game-scoreboard">
            <div class="box">
              <span>Score</span>
              <strong id="game-score">0</strong>
            </div>
            <div class="box">
              <span>Lines</span>
              <strong id="game-lines">0</strong>
            </div>
            <div class="box">
              <span>Level</span>
              <strong id="game-level">1</strong>
            </div>
          </div>
          <p class="game-instruction">矢印キーで移動＆回転（上キー）。スペースキーで一気にドロップ！音は出ないので静かな場所でも安心です。</p>
          <button id="game-start" type="button">ゲームスタート／リスタート</button>
        </div>
      </div>
    </section>
  </main>

  <nav class="global-nav" aria-label="メインメニュー">
    <div class="global-nav-inner">
      <button class="nav-button is-active" type="button" data-nav="counter" aria-pressed="true">
        <div class="nav-icon" aria-hidden="true">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 7H20" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M6 12H18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 17H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </div>
        <strong>文字カウンター</strong>
        <span>Count</span>
      </button>
      <button class="nav-button" type="button" data-nav="game" aria-pressed="false">
        <div class="nav-icon" aria-hidden="true">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="4" y="4" width="7" height="7" rx="1.2" fill="currentColor"/>
            <rect x="13" y="4" width="7" height="9" rx="1.2" stroke="currentColor" stroke-width="1.5"/>
            <rect x="4" y="13" width="7" height="7" rx="1.2" stroke="currentColor" stroke-width="1.5"/>
            <rect x="13" y="15" width="7" height="5" rx="1.2" fill="currentColor"/>
          </svg>
        </div>
        <strong>ゲーム</strong>
        <span>Arcade</span>
      </button>
    </div>
  </nav>

  <script>
    const $ = s => document.querySelector(s);
    const t = $('#t'), chars = $('#chars'), lines = $('#lines'), words = $('#words');
    const mascot = $('.mascot');
    const mascotFace = $('#mascot-face');
    const mascotMessage = $('#mascot-message');
    const defaultReaction = {
      src: 'assets/reaction-waiting.svg',
      alt: 'わくわくして入力を待つ表情',
      message: 'ステージは整ったよ！どんな文章で盛り上げる？'
    };
    const reactions = [
      {
        src: 'assets/reaction-happy.svg',
        alt: '嬉しそうに微笑む表情',
        message: 'リズム最高！そのままビート刻んで！'
      },
      {
        src: 'assets/reaction-energetic.svg',
        alt: '勢いづいてやる気に満ちた表情',
        message: '勢いが出てきたよ！このままクライマックスへ！'
      },
      {
        src: 'assets/reaction-surprised.svg',
        alt: '驚いて目を丸くする表情',
        message: 'わぁ、キラーワードの雨が降ってる〜！'
      },
      {
        src: 'assets/reaction-calm.svg',
        alt: '穏やかに見守る表情',
        message: '深呼吸してステージを丁寧に整えよう。'
      },
      {
        src: 'assets/reaction-hopeful.svg',
        alt: '希望に満ちた微笑みの表情',
        message: 'あとちょっとでフィナーレの予感だよ〜！'
      }
    ];
    let previousReactionIndex = -1;

    function setReaction(reaction) {
      if (!mascotFace || !mascotMessage) return;
      mascotFace.setAttribute('src', reaction.src);
      mascotFace.setAttribute('alt', reaction.alt);
      mascotMessage.textContent = reaction.message;
    }

    function playReaction(text){
      if (!mascot || !mascotFace || !mascotMessage) return;
      if (!text.trim()) {
        setReaction(defaultReaction);
      } else {
        let nextIndex = Math.floor(Math.random() * reactions.length);
        if (reactions.length > 1) {
          while (nextIndex === previousReactionIndex) {
            nextIndex = Math.floor(Math.random() * reactions.length);
          }
        }
        previousReactionIndex = nextIndex;
        const reaction = reactions[nextIndex];
        setReaction(reaction);
      }
      mascot.classList.remove('is-animate');
      void mascot.offsetWidth; // reflow to restart animation
      mascot.classList.add('is-animate');
    }

    function update(triggerAnimation = false){
      const v = t.value;
      chars.textContent = [...v].length; // サロゲート対策
      lines.textContent = v === '' ? 0 : v.split(/\r\n|\r|\n/).length;
      const w = v.trim().split(/\s+/).filter(Boolean);
      words.textContent = v.trim() ? w.length : 0;
      localStorage.setItem('text', v); // 直近内容を保持
      if (triggerAnimation) {
        playReaction(v);
      }
    }
    t.addEventListener('input', ()=> update(true));
    $('#clear').addEventListener('click', ()=>{ t.value=''; update(true); });

    // 前回の内容を復元
    t.value = localStorage.getItem('text') || '';
    update();
    if (t.value) {
      playReaction(t.value);
    } else {
      setReaction(defaultReaction);
    }

    const views = document.querySelectorAll('[data-view]');
    const navButtons = document.querySelectorAll('[data-nav]');
    const controlButtons = document.querySelectorAll('[data-control]');
    let currentView = 'counter';
    const activeView = document.querySelector('[data-view].is-active');
    if (activeView) {
      currentView = activeView.dataset.view;
    }
    views.forEach(view => {
      const isActive = view.dataset.view === currentView;
      view.hidden = !isActive;
      view.classList.toggle('is-active', isActive);
    });
    navButtons.forEach(btn => {
      const isActive = btn.dataset.nav === currentView;
      btn.classList.toggle('is-active', isActive);
      btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });

    function getWebGLContext(canvasElement) {
      if (!canvasElement) return null;
      const contextAttributes = { antialias: true, alpha: true };
      const contextNames = ['webgl', 'experimental-webgl'];
      for (const name of contextNames) {
        const context = canvasElement.getContext(name, contextAttributes);
        if (context) {
          return context;
        }
      }
      return null;
    }

    const canvas = document.getElementById('game-board');
    const gl = getWebGLContext(canvas);
    const gameScoreEl = $('#game-score');
    const gameLinesEl = $('#game-lines');
    const gameLevelEl = $('#game-level');
    const gameBanner = $('#game-banner');
    const gameStartButton = $('#game-start');

    const COLS = 10;
    const ROWS = 18;
    const BLOCK_SIZE = 24;
    function hexToRgb(hex) {
      if (!hex) return [1, 1, 1];
      const normalized = hex.replace('#', '');
      const expanded = normalized.length === 3
        ? normalized.split('').map(char => char + char).join('')
        : normalized.padEnd(6, '0');
      const intValue = parseInt(expanded, 16);
      const r = (intValue >> 16) & 255;
      const g = (intValue >> 8) & 255;
      const b = intValue & 255;
      return [r / 255, g / 255, b / 255];
    }

    function adjustColor(color, amount) {
      const value = Math.max(-1, Math.min(1, amount));
      if (value >= 0) {
        return [
          color[0] + (1 - color[0]) * value,
          color[1] + (1 - color[1]) * value,
          color[2] + (1 - color[2]) * value,
        ];
      }
      const factor = 1 + value;
      return [
        color[0] * factor,
        color[1] * factor,
        color[2] * factor,
      ];
    }
    const COLOR_PALETTE = [null, '#7f7bff', '#ff5db2', '#ffb347', '#66f0c5', '#50c9ff', '#c7a2ff', '#ffe066'];
    const COLOR_RGB = COLOR_PALETTE.map(color => color ? hexToRgb(color) : null);
    const arena = createMatrix(ROWS, COLS);
    const player = { pos: { x: 0, y: 0 }, matrix: null, score: 0, lines: 0, level: 1 };
    let dropInterval = 800;
    let dropTimer = null;
    let isGameRunning = false;
    let isGameOver = false;
    let hasGameStarted = false;
    const clearEffects = [];
    const CLEAR_EFFECT_DURATION = 620;
    const BLOCK_WORLD_SIZE = 0.9;
    const BLOCK_WORLD_GAP = 1.04;
    const BOARD_DEPTH_OFFSET = -0.4;
    const CAMERA_EYE = [0, 6.2, 20.5];
    const CAMERA_CENTER = [0, 0, 0];
    const CAMERA_UP = [0, 1, 0];
    const webglState = gl ? initWebGL(gl) : null;
    if (!webglState && gameBanner) {
      gameBanner.textContent = 'WebGLに対応していないため、ゲームを表示できません。';
    }

    function initWebGL(glContext) {
      const vertexSource = `
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        uniform mat4 uProjection;
        uniform mat4 uView;
        uniform mat4 uModel;
        uniform mat3 uNormalMatrix;
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          vec4 worldPosition = uModel * vec4(aPosition, 1.0);
          vPosition = worldPosition.xyz;
          vNormal = normalize(uNormalMatrix * aNormal);
          gl_Position = uProjection * uView * worldPosition;
        }
      `;
      const fragmentSource = `
        precision mediump float;
        varying vec3 vNormal;
        varying vec3 vPosition;
        uniform vec4 uColor;
        uniform vec3 uLightDirection;
        uniform vec3 uAmbientLight;
        uniform vec3 uFogColor;
        uniform float uFogNear;
        uniform float uFogFar;
        void main() {
          vec3 normal = normalize(vNormal);
          float lightFactor = max(dot(normal, normalize(-uLightDirection)), 0.0);
          vec3 base = uColor.rgb;
          vec3 lighting = base * uAmbientLight + base * lightFactor * 0.75;
          float distanceToCamera = length(vPosition);
          float fogFactor = clamp((uFogFar - distanceToCamera) / (uFogFar - uFogNear), 0.0, 1.0);
          vec3 fogged = mix(uFogColor, lighting, fogFactor);
          gl_FragColor = vec4(fogged, uColor.a);
        }
      `;
      const vertexShader = createShader(glContext, glContext.VERTEX_SHADER, vertexSource);
      const fragmentShader = createShader(glContext, glContext.FRAGMENT_SHADER, fragmentSource);
      if (!vertexShader || !fragmentShader) {
        return null;
      }
      const program = createProgram(glContext, vertexShader, fragmentShader);
      if (!program) {
        return null;
      }
      glContext.useProgram(program);
      const cube = createCubeGeometry();
      const positionBuffer = glContext.createBuffer();
      glContext.bindBuffer(glContext.ARRAY_BUFFER, positionBuffer);
      glContext.bufferData(glContext.ARRAY_BUFFER, cube.positions, glContext.STATIC_DRAW);
      const normalBuffer = glContext.createBuffer();
      glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
      glContext.bufferData(glContext.ARRAY_BUFFER, cube.normals, glContext.STATIC_DRAW);
      const attribLocations = {
        position: glContext.getAttribLocation(program, 'aPosition'),
        normal: glContext.getAttribLocation(program, 'aNormal'),
      };
      glContext.bindBuffer(glContext.ARRAY_BUFFER, positionBuffer);
      glContext.enableVertexAttribArray(attribLocations.position);
      glContext.vertexAttribPointer(attribLocations.position, 3, glContext.FLOAT, false, 0, 0);
      glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
      glContext.enableVertexAttribArray(attribLocations.normal);
      glContext.vertexAttribPointer(attribLocations.normal, 3, glContext.FLOAT, false, 0, 0);
      glContext.enable(glContext.DEPTH_TEST);
      glContext.enable(glContext.CULL_FACE);
      glContext.cullFace(glContext.BACK);
      glContext.clearColor(0.02, 0.03, 0.09, 1);
      const uniformLocations = {
        projection: glContext.getUniformLocation(program, 'uProjection'),
        view: glContext.getUniformLocation(program, 'uView'),
        model: glContext.getUniformLocation(program, 'uModel'),
        normalMatrix: glContext.getUniformLocation(program, 'uNormalMatrix'),
        color: glContext.getUniformLocation(program, 'uColor'),
        lightDirection: glContext.getUniformLocation(program, 'uLightDirection'),
        ambientLight: glContext.getUniformLocation(program, 'uAmbientLight'),
        fogColor: glContext.getUniformLocation(program, 'uFogColor'),
        fogNear: glContext.getUniformLocation(program, 'uFogNear'),
        fogFar: glContext.getUniformLocation(program, 'uFogFar'),
      };
      glContext.uniform3f(uniformLocations.lightDirection, -0.45, -0.9, 0.6);
      glContext.uniform3f(uniformLocations.ambientLight, 0.32, 0.34, 0.44);
      glContext.uniform3f(uniformLocations.fogColor, 0.05, 0.06, 0.15);
      glContext.uniform1f(uniformLocations.fogNear, 6.0);
      glContext.uniform1f(uniformLocations.fogFar, 26.0);
      return {
        program,
        attribLocations,
        uniformLocations,
        buffers: {
          position: positionBuffer,
          normal: normalBuffer,
        },
        cubeVertexCount: cube.vertexCount,
        projection: createMat4(),
        view: createMat4(),
        model: createMat4(),
        normalMatrix: createMat3(),
      };
    }

    function createShader(glContext, type, source) {
      const shader = glContext.createShader(type);
      glContext.shaderSource(shader, source);
      glContext.compileShader(shader);
      if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
        console.error('WebGL shader compile error:', glContext.getShaderInfoLog(shader));
        glContext.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(glContext, vertexShader, fragmentShader) {
      const program = glContext.createProgram();
      glContext.attachShader(program, vertexShader);
      glContext.attachShader(program, fragmentShader);
      glContext.linkProgram(program);
      if (!glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
        console.error('WebGL program link error:', glContext.getProgramInfoLog(program));
        glContext.deleteProgram(program);
        return null;
      }
      return program;
    }

    function createCubeGeometry() {
      const positions = new Float32Array([
        // Front
        -0.5, -0.5, 0.5,
        0.5, -0.5, 0.5,
        0.5, 0.5, 0.5,
        -0.5, -0.5, 0.5,
        0.5, 0.5, 0.5,
        -0.5, 0.5, 0.5,
        // Back
        -0.5, -0.5, -0.5,
        -0.5, 0.5, -0.5,
        0.5, 0.5, -0.5,
        -0.5, -0.5, -0.5,
        0.5, 0.5, -0.5,
        0.5, -0.5, -0.5,
        // Top
        -0.5, 0.5, 0.5,
        0.5, 0.5, 0.5,
        0.5, 0.5, -0.5,
        -0.5, 0.5, 0.5,
        0.5, 0.5, -0.5,
        -0.5, 0.5, -0.5,
        // Bottom
        -0.5, -0.5, 0.5,
        0.5, -0.5, -0.5,
        0.5, -0.5, 0.5,
        -0.5, -0.5, 0.5,
        -0.5, -0.5, -0.5,
        0.5, -0.5, -0.5,
        // Right
        0.5, -0.5, 0.5,
        0.5, -0.5, -0.5,
        0.5, 0.5, -0.5,
        0.5, -0.5, 0.5,
        0.5, 0.5, -0.5,
        0.5, 0.5, 0.5,
        // Left
        -0.5, -0.5, 0.5,
        -0.5, 0.5, -0.5,
        -0.5, -0.5, -0.5,
        -0.5, -0.5, 0.5,
        -0.5, 0.5, 0.5,
        -0.5, 0.5, -0.5,
      ]);
      const normals = new Float32Array([
        // Front
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        // Back
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        0, 0, -1,
        // Top
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        // Bottom
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        // Right
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        1, 0, 0,
        // Left
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
      ]);
      return {
        positions,
        normals,
        vertexCount: 36,
      };
    }

    function resizeWebGLCanvas(glContext, canvasElement) {
      if (!canvasElement) return false;
      const dpr = window.devicePixelRatio || 1;
      const displayWidth = Math.floor(canvasElement.clientWidth * dpr);
      const displayHeight = Math.floor(canvasElement.clientHeight * dpr);
      if (canvasElement.width !== displayWidth || canvasElement.height !== displayHeight) {
        canvasElement.width = displayWidth;
        canvasElement.height = displayHeight;
        return true;
      }
      return false;
    }

    function createMat4() {
      return new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1,
      ]);
    }

    function mat4Identity(out) {
      out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
      out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
      out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
      out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
      return out;
    }

    function mat4Multiply(out, a, b) {
      const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
      const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
      const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
      const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
      const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
      const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
      const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
      const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
      out[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
      out[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
      out[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
      out[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
      out[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
      out[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
      out[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
      out[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
      out[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
      out[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
      out[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
      out[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
      out[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
      return out;
    }

    function mat4Perspective(out, fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = (2 * far * near) * nf;
      out[15] = 0;
      return out;
    }

    function mat4LookAt(out, eye, center, up) {
      let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
      z0 = eye[0] - center[0];
      z1 = eye[1] - center[1];
      z2 = eye[2] - center[2];
      len = Math.hypot(z0, z1, z2);
      if (len === 0) {
        z2 = 1;
      } else {
        z0 /= len;
        z1 /= len;
        z2 /= len;
      }
      x0 = up[1] * z2 - up[2] * z1;
      x1 = up[2] * z0 - up[0] * z2;
      x2 = up[0] * z1 - up[1] * z0;
      len = Math.hypot(x0, x1, x2);
      if (len === 0) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        x0 /= len;
        x1 /= len;
        x2 /= len;
      }
      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
      len = Math.hypot(y0, y1, y2);
      if (len !== 0) {
        y0 /= len;
        y1 /= len;
        y2 /= len;
      }
      out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
      out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
      out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
      out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
      out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
      out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
      out[15] = 1;
      return out;
    }

    function mat4Translate(out, a, v) {
      const x = v[0], y = v[1], z = v[2];
      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      }
      return out;
    }

    function mat4Scale(out, a, v) {
      const x = v[0], y = v[1], z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }

    function createMat3() {
      return new Float32Array([
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
      ]);
    }

    function mat3Identity(out) {
      out[0] = 1; out[1] = 0; out[2] = 0;
      out[3] = 0; out[4] = 1; out[5] = 0;
      out[6] = 0; out[7] = 0; out[8] = 1;
      return out;
    }

    function mat3NormalFromMat4(out, mat) {
      const a00 = mat[0], a01 = mat[1], a02 = mat[2];
      const a10 = mat[4], a11 = mat[5], a12 = mat[6];
      const a20 = mat[8], a21 = mat[9], a22 = mat[10];
      const b01 = a22 * a11 - a12 * a21;
      const b11 = -a22 * a10 + a12 * a20;
      const b21 = a21 * a10 - a11 * a20;
      let det = a00 * b01 + a01 * b11 + a02 * b21;
      if (!det) {
        return mat3Identity(out);
      }
      det = 1.0 / det;
      out[0] = b01 * det;
      out[1] = (-a22 * a01 + a02 * a21) * det;
      out[2] = (a12 * a01 - a02 * a11) * det;
      out[3] = b11 * det;
      out[4] = (a22 * a00 - a02 * a20) * det;
      out[5] = (-a12 * a00 + a02 * a10) * det;
      out[6] = b21 * det;
      out[7] = (-a21 * a00 + a01 * a20) * det;
      out[8] = (a11 * a00 - a01 * a10) * det;
      return out;
    }

    function setBanner(message) {
      if (gameBanner) {
        gameBanner.textContent = message;
      }
    }

    function updateScoreboard() {
      if (gameScoreEl) gameScoreEl.textContent = player.score;
      if (gameLinesEl) gameLinesEl.textContent = player.lines;
      if (gameLevelEl) gameLevelEl.textContent = player.level;
    }

    function createMatrix(rows, cols) {
      return Array.from({ length: rows }, () => Array(cols).fill(0));
    }

    function createPiece(type) {
      switch (type) {
        case 'T':
          return [
            [0, 1, 0],
            [1, 1, 1],
            [0, 0, 0],
          ];
        case 'O':
          return [
            [2, 2],
            [2, 2],
          ];
        case 'L':
          return [
            [0, 0, 3],
            [3, 3, 3],
            [0, 0, 0],
          ];
        case 'J':
          return [
            [4, 0, 0],
            [4, 4, 4],
            [0, 0, 0],
          ];
        case 'S':
          return [
            [0, 5, 5],
            [5, 5, 0],
            [0, 0, 0],
          ];
        case 'Z':
          return [
            [6, 6, 0],
            [0, 6, 6],
            [0, 0, 0],
          ];
        case 'I':
          return [
            [0, 0, 0, 0],
            [7, 7, 7, 7],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
          ];
        default:
          return [[1]];
      }
    }

    function getGhostPosition() {
      if (!player.matrix) return null;
      const ghost = {
        matrix: player.matrix,
        pos: { x: player.pos.x, y: player.pos.y },
      };
      while (!collide(arena, { matrix: ghost.matrix, pos: { x: ghost.pos.x, y: ghost.pos.y + 1 } })) {
        ghost.pos.y++;
        if (ghost.pos.y > ROWS) {
          break;
        }
      }
      return ghost.pos;
    }

    function getBlockWorldPosition(col, row, depthOffset = 0) {
      const offsetX = col - (COLS / 2 - 0.5);
      const offsetY = (ROWS - 1 - row) - (ROWS / 2 - 0.5);
      return [
        offsetX * BLOCK_WORLD_GAP,
        offsetY * BLOCK_WORLD_GAP,
        depthOffset,
      ];
    }

    function drawPrimitive(position, scaleVector, color, alpha = 1) {
      if (!gl || !webglState) return;
      const model = webglState.model;
      mat4Identity(model);
      mat4Translate(model, model, position);
      mat4Scale(model, model, scaleVector);
      gl.uniformMatrix4fv(webglState.uniformLocations.model, false, model);
      mat3NormalFromMat4(webglState.normalMatrix, model);
      gl.uniformMatrix3fv(webglState.uniformLocations.normalMatrix, false, webglState.normalMatrix);
      gl.uniform4f(webglState.uniformLocations.color, color[0], color[1], color[2], alpha);
      gl.drawArrays(gl.TRIANGLES, 0, webglState.cubeVertexCount);
    }

    function drawBlockAt(color, col, row, options = {}) {
      if (!gl || !webglState) return;
      const { alpha = 1, elevation = 0, scale = BLOCK_WORLD_SIZE } = options;
      const position = getBlockWorldPosition(col, row, elevation);
      const scaleVector = Array.isArray(scale) ? scale : [scale, scale, scale];
      drawPrimitive(position, scaleVector, color, alpha);
    }

    function drawMatrix3D(matrix, offset, options = {}) {
      if (!gl || !webglState) return;
      const { alpha = 1, elevation = 0, brightness = 0 } = options;
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (!value) return;
          const color = COLOR_RGB[value] || [1, 1, 1];
          const shaded = brightness !== 0 ? adjustColor(color, brightness) : color;
          const col = x + offset.x;
          const rowIndex = y + offset.y;
          drawBlockAt(shaded, col, rowIndex, { alpha, elevation, scale: BLOCK_WORLD_SIZE });
        });
      });
    }

    function drawGhostPiece(position) {
      if (!player.matrix) return;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(false);
      drawMatrix3D(player.matrix, position, { alpha: 0.45, elevation: -0.1, brightness: 0.25 });
      gl.depthMask(true);
      gl.disable(gl.BLEND);
    }

    function drawPredictionColumns(matrix, currentPos, landingPos) {
      if (!gl || !webglState) return;
      const columnInfo = new Map();
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (!value) return;
          const column = currentPos.x + x;
          const startCell = Math.max(0, currentPos.y + y);
          const endCell = Math.max(startCell + 1, landingPos.y + y + 1);
          const existing = columnInfo.get(column);
          if (!existing) {
            columnInfo.set(column, { startCell, endCell });
          } else {
            existing.startCell = Math.min(existing.startCell, startCell);
            existing.endCell = Math.max(existing.endCell, endCell);
          }
        });
      });
      if (columnInfo.size === 0) return;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(false);
      columnInfo.forEach((info, column) => {
        if (column < 0 || column >= COLS) return;
        const startCell = info.startCell;
        const endCell = Math.max(startCell + 1, info.endCell);
        const centerRow = (startCell + endCell - 1) / 2;
        const height = Math.max(BLOCK_WORLD_GAP * 0.9, (endCell - startCell) * BLOCK_WORLD_GAP);
        const position = getBlockWorldPosition(column, centerRow, -0.25);
        const color = [0.55, 0.62, 1.0];
        drawPrimitive(position, [BLOCK_WORLD_SIZE * 0.35, height, BLOCK_WORLD_SIZE * 0.35], color, 0.35);
      });
      gl.depthMask(true);
      gl.disable(gl.BLEND);
    }

    function addClearEffect(rowIndex) {
      clearEffects.push({
        row: rowIndex,
        start: performance.now(),
      });
      if (clearEffects.length > 24) {
        clearEffects.splice(0, clearEffects.length - 24);
      }
    }

    function drawClearEffects(now) {
      if (!gl || !webglState || clearEffects.length === 0) return;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(false);
      for (let i = clearEffects.length - 1; i >= 0; i--) {
        const effect = clearEffects[i];
        const progress = (now - effect.start) / CLEAR_EFFECT_DURATION;
        if (progress >= 1) {
          clearEffects.splice(i, 1);
          continue;
        }
        const intensity = 1 - progress;
        const basePosition = getBlockWorldPosition((COLS - 1) / 2, effect.row, BOARD_DEPTH_OFFSET + 0.15 - progress * 0.25);
        const width = COLS * BLOCK_WORLD_GAP + 0.6;
        const height = BLOCK_WORLD_GAP * 0.9;
        const color = [1.0, 0.92, 0.68];
        drawPrimitive([basePosition[0], basePosition[1], basePosition[2]], [width, height, 0.4], color, 0.35 * intensity);
      }
      gl.depthMask(true);
      gl.disable(gl.BLEND);
    }

    function drawBoardEnvironment() {
      if (!gl || !webglState) return;
      gl.disable(gl.BLEND);
      gl.depthMask(true);
      const width = COLS * BLOCK_WORLD_GAP + 1.4;
      const height = ROWS * BLOCK_WORLD_GAP + 1.4;
      drawPrimitive([0, 0, BOARD_DEPTH_OFFSET - 0.8], [width, height, 0.6], [0.12, 0.14, 0.32], 1);
      drawPrimitive([0, 0, BOARD_DEPTH_OFFSET - 0.3], [width * 0.94, height * 0.94, 0.4], [0.1, 0.12, 0.28], 1);
      const stageHeight = 0.9;
      const stageY = getBlockWorldPosition(0, ROWS - 0.5, 0)[1] - BLOCK_WORLD_GAP;
      drawPrimitive([0, stageY - 0.6, BOARD_DEPTH_OFFSET - 1.0], [width * 1.05, stageHeight, 3.8], [0.08, 0.09, 0.2], 1);
      drawPrimitive([0, stageY - 0.1, BOARD_DEPTH_OFFSET - 0.6], [width * 0.8, stageHeight * 0.35, 2.4], [0.26, 0.28, 0.6], 1);
    }

    function drawArenaPieces() {
      if (!gl || !webglState) return;
      gl.disable(gl.BLEND);
      gl.depthMask(true);
      arena.forEach((row, y) => {
        row.forEach((value, x) => {
          if (!value) return;
          const color = COLOR_RGB[value] || [1, 1, 1];
          drawBlockAt(color, x, y, { alpha: 1, elevation: 0 });
        });
      });
    }

    function drawActivePiece(now) {
      if (!gl || !webglState || !player.matrix) return;
      const ghostPos = getGhostPosition();
      if (ghostPos) {
        drawPredictionColumns(player.matrix, player.pos, ghostPos);
        drawGhostPiece(ghostPos);
      }
      gl.disable(gl.BLEND);
      gl.depthMask(true);
      const pulse = Math.sin(now / 320) * 0.04;
      drawMatrix3D(player.matrix, player.pos, { alpha: 1, elevation: 0.32, brightness: 0.18 + pulse });
    }

    function draw(now = performance.now()) {
      if (!gl || !webglState || !canvas) return;
      resizeWebGLCanvas(gl, canvas);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(webglState.program);
      const aspect = canvas.width > 0 && canvas.height > 0 ? canvas.width / canvas.height : 1;
      mat4Perspective(webglState.projection, Math.PI / 4, aspect, 0.1, 80);
      gl.uniformMatrix4fv(webglState.uniformLocations.projection, false, webglState.projection);
      mat4LookAt(webglState.view, CAMERA_EYE, CAMERA_CENTER, CAMERA_UP);
      gl.uniformMatrix4fv(webglState.uniformLocations.view, false, webglState.view);
      drawBoardEnvironment();
      drawArenaPieces();
      drawActivePiece(now);
      drawClearEffects(now);
    }

    function merge(arena, player) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

    function collide(arena, player) {
      for (let y = 0; y < player.matrix.length; y++) {
        for (let x = 0; x < player.matrix[y].length; x++) {
          if (player.matrix[y][x] !== 0) {
            const row = arena[y + player.pos.y];
            if (!row || row[x + player.pos.x] !== 0) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < y; x++) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (dir > 0) {
        matrix.forEach(row => row.reverse());
      } else {
        matrix.reverse();
      }
    }

    function arenaSweep() {
      let rowCount = 0;
      for (let y = arena.length - 1; y >= 0; y--) {
        if (arena[y].every(value => value !== 0)) {
          addClearEffect(y);
          arena.splice(y, 1);
          arena.unshift(new Array(COLS).fill(0));
          rowCount++;
          y++;
        }
      }
      if (rowCount > 0) {
        player.score += rowCount * rowCount * 120 * player.level;
        player.lines += rowCount;
        if (rowCount >= 4) {
          setBanner('テトリス成功！会場がどよめいてるよ！');
        } else if (rowCount > 1) {
          setBanner(`${rowCount}ラインコンボ！リズムに乗ってる！`);
        } else {
          setBanner('1ラインクリア！いい流れだね！');
        }
        if (player.lines >= player.level * 8) {
          player.level++;
          dropInterval = Math.max(150, dropInterval - 70);
          if (isGameRunning && !isGameOver) {
            restartDropTimer();
            setBanner(`レベル${player.level}にアップ！スピード注意！`);
          }
        }
        updateScoreboard();
      }
    }

    function restartDropTimer() {
      stopDropTimer();
      if (isGameRunning && !isGameOver) {
        dropTimer = setInterval(playerDrop, dropInterval);
      }
    }

    function stopDropTimer() {
      if (dropTimer) {
        clearInterval(dropTimer);
        dropTimer = null;
      }
    }

    function playerReset() {
      if (!canvas || !gl || !webglState) return;
      const pieces = 'TJLOSZI';
      const type = pieces[Math.floor(Math.random() * pieces.length)];
      player.matrix = createPiece(type);
      player.pos.y = 0;
      player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);
      if (collide(arena, player)) {
        isGameOver = true;
        isGameRunning = false;
        setBanner('ゲームオーバー！ゲームスタートで再挑戦してね。');
        stopDropTimer();
        player.matrix = null;
      }
    }

    function playerDrop() {
      if (!isGameRunning || isGameOver) return;
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        playerReset();
      }
      draw();
    }

    function hardDrop() {
      if (!isGameRunning || isGameOver) return;
      while (!collide(arena, player)) {
        player.pos.y++;
      }
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      playerReset();
      draw();
      if (!isGameOver) {
        restartDropTimer();
      }
    }

    function playerMove(dir) {
      if (!isGameRunning || isGameOver) return;
      player.pos.x += dir;
      if (collide(arena, player)) {
        player.pos.x -= dir;
      } else {
        draw();
      }
    }

    function playerRotate(dir) {
      if (!isGameRunning || isGameOver) return;
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.pos.x = pos;
          return;
        }
      }
      draw();
    }

    function startGame() {
      if (!canvas || !gl || !webglState) return;
      stopDropTimer();
      arena.forEach(row => row.fill(0));
      player.score = 0;
      player.lines = 0;
      player.level = 1;
      dropInterval = 800;
      isGameOver = false;
      isGameRunning = true;
      hasGameStarted = true;
      player.matrix = null;
      updateScoreboard();
      setBanner('ブロックショー開演！矢印キーで操作してね。');
      playerReset();
      if (!isGameOver) {
        draw();
        restartDropTimer();
      } else {
        draw();
      }
    }

    function pauseGame() {
      if (!hasGameStarted || isGameOver) {
        isGameRunning = false;
        stopDropTimer();
        return;
      }
      if (!isGameRunning) return;
      isGameRunning = false;
      stopDropTimer();
      setBanner('ポーズ中。ゲームメニューで再開しよう！');
    }

    function resumeGame() {
      if (!hasGameStarted || isGameOver) return;
      if (isGameRunning) return;
      isGameRunning = true;
      setBanner('再開！ブロックの雨をさばいてね！');
      restartDropTimer();
    }

    function triggerControl(action) {
      switch (action) {
        case 'left':
          playerMove(-1);
          break;
        case 'right':
          playerMove(1);
          break;
        case 'down':
          playerDrop();
          break;
        case 'rotate':
          playerRotate(1);
          break;
        case 'drop':
          hardDrop();
          break;
        default:
          break;
      }
    }

    let controlHoldTimer = null;
    let controlHoldAction = null;
    const holdableControls = new Set(['left', 'right', 'down']);
    const controlIntervals = {
      left: 140,
      right: 140,
      down: 90,
    };

    function stopControlHold() {
      if (controlHoldTimer) {
        clearInterval(controlHoldTimer);
        controlHoldTimer = null;
      }
      controlHoldAction = null;
    }

    function startControlHold(action) {
      if (!holdableControls.has(action)) {
        triggerControl(action);
        return;
      }
      if (controlHoldAction === action) return;
      stopControlHold();
      triggerControl(action);
      if (!isGameRunning || isGameOver || currentView !== 'game') {
        controlHoldAction = null;
        return;
      }
      const interval = controlIntervals[action] || 140;
      controlHoldAction = action;
      controlHoldTimer = setInterval(() => {
        triggerControl(action);
      }, interval);
    }

    function handleGameKey(event) {
      if (currentView !== 'game' || !hasGameStarted || isGameOver) return;
      if (!isGameRunning) return;
      const key = event.key;
      if (key === 'ArrowLeft') {
        event.preventDefault();
        playerMove(-1);
      } else if (key === 'ArrowRight') {
        event.preventDefault();
        playerMove(1);
      } else if (key === 'ArrowDown') {
        event.preventDefault();
        playerDrop();
      } else if (key === 'ArrowUp') {
        event.preventDefault();
        playerRotate(1);
      } else if (key === ' ' || key === 'Spacebar') {
        event.preventDefault();
        hardDrop();
      }
    }

    function switchView(target) {
      if (!target) return;
      stopControlHold();
      if (target === currentView) {
        if (target === 'game' && hasGameStarted && !isGameOver) {
          resumeGame();
        }
        return;
      }
      currentView = target;
      views.forEach(view => {
        const isActive = view.dataset.view === target;
        view.classList.toggle('is-active', isActive);
        view.hidden = !isActive;
      });
      navButtons.forEach(btn => {
        const isActive = btn.dataset.nav === target;
        btn.classList.toggle('is-active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
      if (target === 'game') {
        if (!hasGameStarted) {
          startGame();
        } else if (!isGameOver) {
          resumeGame();
        } else {
          setBanner('ゲームオーバー！ゲームスタートで再挑戦してね。');
        }
      } else {
        pauseGame();
      }
    }

    navButtons.forEach(btn => {
      btn.addEventListener('click', () => switchView(btn.dataset.nav));
    });
    const shouldPreventPointerDefault = event => {
      return event.pointerType !== 'touch';
    };
    if (controlButtons.length) {
      controlButtons.forEach(button => {
        const action = button.dataset.control;
        if (!action) return;
        if (holdableControls.has(action)) {
          button.addEventListener('pointerdown', event => {
            if (shouldPreventPointerDefault(event)) {
              event.preventDefault();
            }
            startControlHold(action);
          });
          button.addEventListener('pointerup', event => {
            if (shouldPreventPointerDefault(event)) {
              event.preventDefault();
            }
            stopControlHold();
          });
          button.addEventListener('pointerleave', stopControlHold);
          button.addEventListener('pointercancel', stopControlHold);
          button.addEventListener('click', event => event.preventDefault());
        } else {
          button.addEventListener('pointerdown', event => {
            if (shouldPreventPointerDefault(event)) {
              event.preventDefault();
            }
          });
          button.addEventListener('click', event => {
            event.preventDefault();
            triggerControl(action);
          });
        }
        button.addEventListener('keydown', event => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            triggerControl(action);
          }
        });
      });
      window.addEventListener('pointerup', stopControlHold);
      window.addEventListener('pointercancel', stopControlHold);
    }
    if (gameStartButton) {
      gameStartButton.addEventListener('click', () => {
        startGame();
        if (currentView !== 'game') {
          switchView('game');
        }
      });
    }
    document.addEventListener('keydown', handleGameKey);
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && currentView === 'game') {
        pauseGame();
      } else if (!document.hidden && currentView === 'game' && hasGameStarted && !isGameOver) {
        resumeGame();
      }
    });

    updateScoreboard();
    if (gl && webglState && canvas) {
      const render = () => {
        draw();
        requestAnimationFrame(render);
      };
      render();
    }

    // サービスワーカー登録（PWAのオフライン化）
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>
</body>
</html>
